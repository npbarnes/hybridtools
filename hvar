#!/usr/bin/env python
import numpy as np
from HybridReader2 import HybridReader2 as hr
from HybridHelper import parser, parse_cmd_line, direct_plot, beta_plot
import matplotlib.pyplot as plt
from matplotlib import colors, rcParams

def var_sanity_check(isScalar, coord):
    if h.isScalar and args.variable.coordinate is not None:
        raise ValueError("Don't specify a coordinate for scalars.")
    if not h.isScalar and args.variable.coordinate is None:
        raise ValueError("Must specify a coordinate for vectors.")

parser.add_argument('-s','--step', dest='stepnum', type=int, default=-1,
        help='The specific step number to read or -1 for the last step')
args = parse_cmd_line()

fig, (ax1, ax2) = plt.subplots(ncols=2, sharex=True, sharey=True,
        figsize=(2*rcParams['figure.figsize'][0], 0.8*rcParams['figure.figsize'][1]))
fig.subplots_adjust(left=0.05, right=0.95, top=0.95, bottom=0.05, wspace=0.1)
ax1.set_aspect('equal', adjustable='box-forced')
ax2.set_aspect('equal', adjustable='box-forced')

if args.variable.name == 'beta':
    hn = hr(args.prefix, 'np')
    para = hn.para
    n = hn.get_timestep(args.stepnum)[-1]
    T = hr(args.prefix, 'temp_p').get_timestep(args.stepnum)[-1]
    B = hr(args.prefix, 'bt').get_timestep(args.stepnum)[-1]

    # Convert units
    n = n/(1000.0**3)                    # 1/km^3 -> 1/m^3
    T = 1.60218e-19 * T                  # eV -> J
    B = 1.6726219e-27/1.60217662e-19 * B # proton gyrofrequency -> T

    # Compute B \cdot B
    B2 = np.sum(B**2, axis=-1)

    # Compute plasma beta
    data = n*T/(B2/(2*1.257e-6))

    beta_plot(fig, ax1, data, para, 'xy')
    beta_plot(fig, ax2, data, para, 'xz')

elif args.variable.name == 'bmag':
    hb = hr(args.prefix, 'bt')
    para = hb.para
    B = hb.get_timestep(args.stepnum)[-1]
    B = 1.6726219e-27/1.60217662e-19 * B # proton gyrofrequency -> T
    Bmag = np.sqrt(np.sum(B**2, axis=-1))
    data = Bmag

    direct_plot(fig, ax1, data, para, 'xy', cmap=args.colormap, norm=args.norm, vmin=args.vmin, vmax=args.vmax)
    direct_plot(fig, ax2, data, para, 'xz', cmap=args.colormap, norm=args.norm, vmin=args.vmin, vmax=args.vmax)

elif args.variable.name == 'fmach':
    hn = hr(args.prefix, 'np')
    para = hn.para
    n = hn.get_timestep(args.stepnum)[-1]
    T = hr(args.prefix, 'temp_p').get_timestep(args.stepnum)[-1]
    B = hr(args.prefix, 'bt').get_timestep(args.stepnum)[-1]
    u = hr(args.prefix, 'up').get_timestep(args.stepnum)[-1]
    ux = -u[:,:,:,0]

    n = n/(1000.0**3)                    # 1/km^3 -> 1/m^3
    T = 1.60218e-19 * T                  # eV -> J
    B = 1.6726219e-27/1.60217662e-19 * B # proton gyrofrequency -> T

    B2 = np.sum(B**2, axis=-1)

    c   = 3e8       # m/s
    mu0 = 1.257e-6  # H/m
    mp  = 1.602e-19 # kg
    gamma = 3

    # Upstream alfven velocity
    us_va = np.sqrt(B2[-1,0,0]/(mu0*mp*n[-1,0,0]))

    # Upstream ion acousitic speed
    us_vs = np.sqrt(gamma*T[-1,0,0]/mp)

    # Upstream fastmode velocity
    us_vf = c*np.sqrt((us_vs**2 + us_va**2)/(c**2 + us_va**2))

    data = ux/us_vf

    direct_plot(fig, ax1, data, para, 'xy', cmap=args.colormap, norm=args.norm, vmin=args.vmin, vmax=args.vmax)
    direct_plot(fig, ax2, data, para, 'xz', cmap=args.colormap, norm=args.norm, vmin=args.vmin, vmax=args.vmax)

else:
    h = hr(args.prefix,args.variable.name)
    var_sanity_check(h.isScalar, args.variable.coordinate)

    data = h.get_timestep(args.stepnum)[-1]
    if not h.isScalar:
        data = data[:,:,:,args.variable.coordinate]
    para = h.para

    direct_plot(fig, ax1, data, para, 'xy', cmap=args.colormap, norm=args.norm, vmin=args.vmin, vmax=args.vmax)
    direct_plot(fig, ax2, data, para, 'xz', cmap=args.colormap, norm=args.norm, vmin=args.vmin, vmax=args.vmax)



# set reasonable axis limits. (note than since axes are shared and aspect is equal this changes all limits.)
ax1.autoscale('tight')
if args.ylim is not None:
    ax1.set_ylim(*args.ylim)

# Making axes shared automatically hides the yaxis tick labels. This makes them visible again.
for tk in ax2.get_yticklabels():
    tk.set_visible(True)

fig.suptitle(args.variable, fontsize=14)

if args.save:
    fig.savefig(args.save, bbox_inches='tight')
else:
    plt.show()
