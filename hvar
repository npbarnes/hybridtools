#!/usr/bin/python
import numpy as np
from HybridReader2 import HybridReader2 as hr
from HybridHelper import parser
import matplotlib.pyplot as plt
import matplotlib.ticker as plticker
from matplotlib.colors import Normalize, SymLogNorm
import colormaps as cmaps
plt.register_cmap(name='viridis', cmap=cmaps.viridis)
plt.register_cmap(name='plasma', cmap=cmaps.plasma)
from sys import argv
from bisect import bisect
import argparse

parser.add_argument('-s','--step', dest='stepnum', type=int, default=-1, help='The specific step number to read')
args = parser.parse_args()

den = hr(args.prefix,args.variable)
if den.isScalar and args.coordinate is not None:
    raise Exception("Don't specify a coordinate for scalars.")
if not den.isScalar and args.coordinate is None:
    raise Exception("Must specify a coordinate for vectors.")

ddata = den.get_timestep(args.stepnum)[-1]

if not den.isScalar:
    ddata = ddata[:,:,:,args.coordinate]

# Get grid spacing
qx = den.para['qx']
qy = den.para['qy']
qzrange = den.para['qzrange']

# Find the center index of the grid
cx = den.para['nx']/2
cy = den.para['ny']/2
cz = den.para['zrange']/2

# the offset of pluto from the center isn't always availible
try:
    po = den.para['pluto_offset']
except KeyError:
    print("Couldn't get pluto_offset. It has been assumed to be 30, but it probably isn't.")
    po = 30

# Set constatnt for Pluto radius 
Rp = 1187. # km

# Shift grid so that Pluto lies at (0,0,0) and convert from km to Rp
qx = (qx - qx[len(qx)/2 + po])/Rp
qy = (qy - qy[len(qy)/2])/Rp
qzrange = (qzrange - qzrange[len(qzrange)/2])/Rp

if den.isScalar:
    title = args.variable
else:
    title = '{} {}'.format(args.variable,args.coordinate)

# Make X-Y plot
X,Y = np.meshgrid(qx,qy)
plt.pcolormesh(X,Y,ddata[:,:,cz].transpose(), cmap=args.colormap, norm=SymLogNorm(0.001))
plt.colorbar()
plt.xlim(qx[0],qx[-1])
plt.ylim(qy[0],qy[-1])
plt.title(title)
plt.xlabel('X ($R_p$)')
plt.ylabel('Y ($R_p$)')
plt.gca().set_aspect('equal') # equal aspect ratio
loc = plticker.MultipleLocator(base=20)
ax = plt.gca()
ax.yaxis.set_major_locator(loc)



# Make X-Z plot
plt.figure()
X,Z = np.meshgrid(qx,qzrange)

plt.pcolormesh(X,Z,ddata[:,cy,:].transpose(), cmap=args.colormap, norm=SymLogNorm(0.001))
plt.colorbar()
plt.xlim(qx[0],qx[-1])
plt.ylim(qzrange[0],qzrange[-1])
plt.title(title)
plt.xlabel('X ($R_p$)')
plt.ylabel('Z ($R_p$)')
plt.gca().set_aspect('equal') # equal aspect ratio
loc = plticker.MultipleLocator(base=20)
ax = plt.gca()
ax.yaxis.set_major_locator(loc)

# Make Y-Z plot
xind = bisect(qx,0)

plt.figure()
Y,Z = np.meshgrid(qy,qzrange)

plt.pcolormesh(Y,Z,ddata[-1,:,:].transpose(), cmap=args.colormap, norm=SymLogNorm(0.001))
plt.colorbar()
plt.xlim(qy[0],qy[-1])
plt.ylim(qzrange[0],qzrange[-1])
plt.title(title)
plt.xlabel('Y ($R_p$)')
plt.ylabel('Z ($R_p$)')
plt.gca().set_aspect('equal') # equal aspect ratio
loc = plticker.MultipleLocator(base=20)
ax = plt.gca()
ax.yaxis.set_major_locator(loc)

plt.show()
